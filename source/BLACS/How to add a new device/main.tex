\documentclass[12pt]{article}
\include{pythonlisting}
\usepackage{setspace}
\usepackage[margin=1.5cm]{geometry}


\begin{document}\title{How to add a new type of hardware device to BLACS}
\date{\today}
\maketitle
\setstretch{1.2}
\section{Introduction}
This tutorial covers the basics of adding a new hardware device type to BLACS. 
Existing device types include the PulseBlaster, NovatechDDS9m, NI PCIe 6363 and NI PCI 6733. 
These classes are used by BLACS to generate the unique tab for each device on the BLACS front panel. 
Adding support for your device to BLACS does not add support to labscript, which will also need to be done if you wish to use the device in a buffered sequence (see labscript documentation). 

This tutorial assumes a working knowledge of Python. 
Some advanced sections also require a working knowledge of PySide (very similar to PyQt) and QtDesigner. 
If are not familiar with one or more of these, please attempt a tutorial on the subject before continuing with this guide!

\subsection{Creating the Device Classes}\label{creating class}
All device classes as stored in pythonlib/BLACS/hardware\_interfaces. 
You should create a new file for your device in this folder, with an appropriate name (the name should be the lowercase version of the device class used in labscript). 
We shall refer to the name in this tutorial as \texttt{pulseblaster.py}).

The first thing you need to do in your empty python file is import the required packages and classes.
The code below imports the BLACS backend classes for the tab state machine (we'll cover these more as we go).
You can also optionally import PySide if you wish to add more PySide widgets to the interface yourself (see section \ref{??})
\begin{python}
from BLACS.tab_base_classes import Worker, define_state
from BLACS.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED
from BLACS.tab_base_classes import MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
from BLACS.device_base_class import DeviceTab
\end{python}

Next we need to define two classes. 
The first class will handle the GUI, and related events. 
The second will handle the communication with the actual hardware. 
The first class name (hence forth known as the device class) should be the lower case version of the device class shown in the entry in the connection table for an instance of your device. 
It should also be the same name as your python file. 
You may call the second class (hence forth known as the worker class) whatever you wish, though it is advisable to use something understandable!

In this tutorial we will use \texttt{my\_device} and \texttt{MyWorker} as our class names. 

\begin{python}
class my_device(DeviceTab):
    pass
	
class MyWorker(Worker):
    pass
\end{python}

\textbf{Note:} We have used \texttt{pass} here as a placeholder. 
You can assume that the \texttt{pass} statements will be removed once the tutorial inserts code at the same indentation level.


\section{Implementing a simple Device Class}\label{device_class}
The device class handles the creation of the GUI and the interaction with the GUI and the Queue Manager. 
Most of this is handled by the \texttt{DeviceTab} class you are subclassing.
We'll first discuss the minimum requirements for subclassing \texttt{DeviceTab}, followed by an in depth explanation of the internal workings of \texttt{DeviceTab} and details on advanced implementation possibilities.

When the device tab is instantiated, the functions described in the next sections are run in the following order:
\begin{python}
    self.initialise_GUI() 
    self.restore_save_data(settings_dictionary)
    self.initialise_workers()
    self.initialise_device()
\end{python}

\subsection{Overriding the \texttt{initialise\_GUI} function}
The \texttt{initialise\_GUI} function is where you define the output capabilities of your device and generate the graphical interface for manual control of the device through the front panel.
The \texttt{DeviceTab} class you are subclassing has a lot of function to help you do this.
Here we'll walk through a simple example, but for full details see the \texttt{DeviceTab} reference in section \ref{device_class_reference}.

The first step is to override the \texttt{initialise\_GUI} function and define some capabilities of the device:

\begin{python}
def initialise_GUI(self):
    # Capabilities
    self.num_DDS = 2
    self.num_DO = 12
    self.ao_base_units     = 'V'
    self.ao_base_min       = -10.0
    self.ao_base_max       =  10.0
    self.ao_base_step      =  0.001
    self.ao_base_decimals  =  3
    self.dds_base_units    = {'freq':'Hz',        'amp':'Vpp', 'phase':'Degrees'}
    self.dds_base_min      = {'freq':0.3,         'amp':0.0,   'phase':0}
    self.dds_base_max      = {'freq':150000000.0, 'amp':1.0,   'phase':360}
    self.dds_base_step     = {'freq':1000000,     'amp':0.01,  'phase':1}
    self.dds_base_decimals = {'freq':1,           'amp':3,     'phase':3}
\end{python}
This should look pretty straight forward, we are just storing in a dictionary the number of DDS and digital outputs, followed by the capabilities of the DDSs of the device in \textbf{base units}. 
Base units are considered to be SI units like Volts, Hz, etc.
Base units are not necessarily the same as hardware units (more on this later).
All of this information is for your own use, and does not have to follow any particular naming convention, nor does it have to be stored as an instance atrribute using \texttt{self}.

Following this you should define 1-3 dictionaries which define the properties of the digital, analog and DDS output channels respectively.
If your devices does not have one or more of these types of outputs, you do not need to create the dictionary of properties.

For digital outputs, the dictionary should be of the form:
\begin{python}
    digital_properties = {'hardware_channel_1':{},
                          'hardware_channel_2':{}
                         }
\end{python}
where \texttt{hardware\_channel\_x} is the name of the channel connection as specified in your \texttt{labscript} implementation. For instance PulseBlasters would use Flag 1, Flag 2, etc. while NI PCIe 6363s would use port0/line0, port0/line1, etc.

For analog outputs, the dictionary should be of the form:
\begin{python}
    analog_properties = {'hardware_channel_1':{'base_unit':self.ao_base_units,
                                               'min':self.ao_base_min,
                                               'max':self.ao_base_max,
                                               'step':self.ao_base_step,
                                               'decimals':self.ao_base_decimals
                                              },
                         'hardware_channel_2':{'base_unit':self.ao_base_units,
                                               'min':self.ao_base_min,
                                               'max':self.ao_base_max,
                                               'step':self.ao_base_step,
                                               'decimals':self.ao_base_decimals
                                              },
                        }
\end{python}
where, again, \texttt{hardware\_channel\_x} is the name of the channel connection as specified in your \texttt{labscript} implementation.

DDS properties are combination of three analog properties and a digital property.
The DDS property dictionary should thus be of the form:
\begin{python}
    # The creation of this dictionary could be simplified by one or
    # more for loops. However we chose to write everything out explicitly
    # here so that it is clear what is going on. Consult one of the already 
    # implemented device classes to see how it could be done in fewer lines
    # of code (for example the PulseBlaster)
    dds_properties = {'hardware_channel_1':
                           {'freq':{'base_unit':self.dds_base_units['freq'],
                                    'min':self.dds_base_min['freq'],
                                    'max':self.dds_base_max['freq'],
                                    'step':self.dds_base_step['freq'],
                                    'decimals':self.dds_base_decimals['freq']
                                   },
                             'amp':{'base_unit':self.dds_base_units['amp'],
                                    'min':self.dds_base_min['amp'],
                                    'max':self.dds_base_max['amp'],
                                    'step':self.dds_base_step['amp'],
                                    'decimals':self.dds_base_decimals['amp']
                                   },
												  'phase':{'base_unit':self.dds_base_units['phase'],
                                    'min':self.dds_base_min['phase'],
                                    'max':self.dds_base_max['phase'],
                                    'step':self.dds_base_step['phase'],
                                    'decimals':self.dds_base_decimals['phase']
                                   },
                            'gate':{}
                            },

                      'hardware_channel_2':
                           {'freq':{'base_unit':self.dds_base_units['freq'],
                                    'min':self.dds_base_min['freq'],
                                    'max':self.dds_base_max['freq'],
                                    'step':self.dds_base_step['freq'],
                                    'decimals':self.dds_base_decimals['freq']
                                   },
                             'amp':{'base_unit':self.dds_base_units['amp'],
                                    'min':self.dds_base_min['amp'],
                                    'max':self.dds_base_max['amp'],
                                    'step':self.dds_base_step['amp'],
                                    'decimals':self.dds_base_decimals['amp']
                                   },
												  'phase':{'base_unit':self.dds_base_units['phase'],
                                    'min':self.dds_base_min['phase'],
                                    'max':self.dds_base_max['phase'],
                                    'step':self.dds_base_step['phase'],
                                    'decimals':self.dds_base_decimals['phase']
                                   },
                            'gate':{}
                            }
                     }
\end{python}
where, again, \texttt{hardware\_channel\_x} is the name of the channel connection as specified in your \texttt{labscript} implementation.
Importantly, if you omit any of the freq, amp, phase or gate entries, it will be assumed that the DDS output does not have control over that parameter. 
For instance you may have a frequency source for which you cannot control the amplitude or phase, nor does it have an on/off control (gate). 
As such you would define your dds dictionary as:
\begin{python}
    dds_properties = {'hardware_channel_1':
                           {'freq':{'base_unit':self.dds_base_units['freq'],
                                    'min':self.dds_base_min['freq'],
                                    'max':self.dds_base_max['freq'],
                                    'step':self.dds_base_step['freq'],
                                    'decimals':self.dds_base_decimals['freq']
                                   }
                            }
                      }
\end{python}

You should then call one or more of the following functions to create python objects for your outputs:
\begin{python}   
    self.create_digital_outputs(digital_properties)
    self.create_analog_outputs(analog_properties)
    self.create_dds_outputs(dds_properties)
\end{python}
The objects create exist behind the scenes, and will have automatically looked up relevant entries in the connection table to get their name and unit conversion class.

You should then create the widgets for each of these outputs. 
There are several ways you can do this, each of which is explained in ??\ref{??}.
The simplest is to let the \texttt{DeviceTab} do it for you, as follows:
\begin{python}
    dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
\end{python}
Note that three dictionaries are always returned, regardless of whether you are using any digital, analog and dds outputs on your device.
For instance, if you have not create any analog outputs as detailed above, the \texttt{ao\_widgets} variable will contain an empty dictionary.

You must then place these widgets in the GUI tab for your device.
Again, this can be done several ways (see ??\ref{??}), but the simplest is to do:
\begin{python}
    self.auto_place_widgets(dds_widgets,do_widgets)
\end{python}
The order in which you pass the dictionaries of widgets determines the order they appear in the device tab.
You can split up the dictionaries of widgets if you like, for instance to segregate some digital outputs from the others.
You can also specify heading names, and a sorting function for each group of widgets you pass to this function (see section \ref{??} for details).

If you wish to add additional GUI elements, you may do so before or after the call to \texttt{auto\_place\_widgets}.
You can access the Qt Layout which contains the main body of the tab using:
\begin{python}
    self.get_tab_layout()
\end{python}
You can then insert/append Qt Widgets or layouts you have created either from code or by loading a Qt UI file created by Qt Designer.

%TODO: Explain other ways to call auto_place_widgets for controlling group name/sort order.


\subsection{Overriding the \texttt{get\_save\_data} and \texttt{restore\_save\_data} functions}
You may find you wish to save and restore some data from your tab when BLACS is closed or the tab is restarted.
\texttt{DeviceTab} provides two functions to override to implement this behaviour.

\texttt{get\_save\_data} should be implemented to return a dictionary of key:value pairs you wish saved.

\texttt{restore\_save\_data} provides a dictionary of key:value pairs to restore as you wish.

The signatures of the functions are:
\begin{python}
def get_save_data(self):
	# your code here
	pass
	
def restore_save_data(self, save_data):
	# your code here
	pass
\end{python}

The dictionary you return must meet the following requirements:
\begin{python}
# This expression must be true
eval(repr(my_save_data)) == my_save_data 
\end{python}

See the Camera device class implementation for an example.

\subsection{Overriding the \texttt{initialise\_workers} function}
The \texttt{initialise\_workers} function is used to tell the device Tab to launch one or more worker processes to communicate with the device.
A device tab can have one or more associated worker processes, with one of them being identified as the \textit{primary worker}.
When the device tab enters one of the states inbuilt into \texttt{DeviceTab} (such as \texttt{transition\_to\_buffered}, the primary worker is communicated with first. 
Following this, communication with secondary worker processes commences one after the other.
The order in which secondary processes are chosen to communicate with depends on the names of all worker processes and the number of worker processes.
We simply iterate over a dictionary of worker processes, keyed by the worker process name (watch the PyCon ``The mighty dictionary'' video online for more information on Python dictionary ordering).
If you require secondary worker processes to be communicated with in a specific order, please contact the developers and request this feature to be added.

To launch a worker process, simply call:
\begin{python}
def initialise_workers(self):
    self.create_worker("my_worker", MyWorker)
\end{python}
where \texttt{my\_worker} is a unique name for this worker process and \texttt{MyWorker} is the class name you wish to launch in the new worker process.

\texttt{create\_worker} also takes a third, optional dictionary of keyword arguments to pass into the worker process (see section \ref{??}).
A good piece of information to pass in would be the \texttt{BLACS\_connection attribute} specified in the connection table.
This parameter usually contains information specifying the physical data connection to the PC (Eg. COM12), and is available as an instance attribute of \texttt{DeviceClass}:
\begin{python}
def initialise_workers(self):
    self.create_worker("my_worker", MyWorker,{'com_port':str(self.BLACS_connection))
\end{python}
You can access this value from within the Worker Class using \texttt{self.com\_port}.

Finally, you need to set the primary worker.
Do do this, simply write:
\begin{python}
    self.primary_worker = "my_worker"
\end{python}
where \texttt{my\_worker} is the name you used in the call to \texttt{create\_worker}


\subsection{Overriding the \texttt{start\_run} function}
If your device is a pseudoclock, you will need to override the \texttt{start\_run} function.
This function is called by the Queue Manager to begin a buffered experiment shot.
\textbf{This function must be a state function (see section \ref{device_class_state_machine.}}
\textbf{You will also need to become familiar with the \texttt{statemachine\_timeout\_add} functionality to schedule a regular poll of the device before continuing with this section (see section \ref{statemachine_timeout_add}.}
Your implementation of \texttt{start\_run} will be passed a queue which it will use to notify the Queue Manager when the experiment shot has finished running.
\textbf{It is up to you to schedule a poll of your device to determine if the shot has completed.}

Below is the PulseBlaster implementation:
\begin{python}
@define_state(MODE_BUFFERED,True)  
def start_run(self, notify_queue):
    self.statemachine_timeout_remove(self.status_monitor)
    yield(self.queue_work(self.primary_worker,'pb_start'))
    self.statemachine_timeout_add(100,self.status_monitor,notify_queue)
\end{python}

In this implementation, we first stop the existing poll of the device status.
We then ask the worker process to start the buffered shot.
Once the shot has begun, we setup a regular poll of the pulseblaster every 100\,ms which will notify the Queue Manager at the end of the shot using the \texttt{notify\_queue}.


\section{\texttt{DeviceTab} reference}\label{device_class_reference}
% TODO: List attributes and functions that will be of use to people subclassing DeviceTab





\newpage
\section{Advanced features of the \texttt{DeviceTab}}
\subsection{The state machine}\label{device_class_state_machine}
The \texttt{Tab} class (\texttt{DeviceTab} subclasses \texttt{Tab}) contains a state machine which regulates the interprocess communication between the worker process and the GUI process, as well as making sure that the Qt event based architecture is transformed into a deterministic system. 
The simple Device Class implementation discussed in section \ref{device_class} is already using the state machine behind the scenes.

Most of the state machine architecture is hidden within the \texttt{Tab} class. 
Any function in the device class prefixed (decorated) with \texttt{@define\_state} will be queued up appropriately in the state machine when it is called.
We will refer to functions prefixed with \texttt{@define\_state} as \textit{state machine functions}.

The state machine has 4 modes it can be in: \texttt{MODE\_MANUAL}, \texttt{MODE\_TRANSITION\_TO\_BUFFERED}, \texttt{MODE\_BUFFERED} and \texttt{MODE\_TRANSITION\_TO\_MANUAL}. These 4 modes correspond to the following situations for the device:

\begin{itemize}
	\item \texttt{MODE\_MANUAL}: The device is programmed to static values that match the front panel interface of BLACS. The device is \textbf{not} running a buffered experiment compiled by \texttt{labscript}.
	\item \texttt{MODE\_TRANSITION\_TO\_BUFFERED}: The device is being programmed with a buffered sequence from a HDF5 file.
	\item \texttt{MODE\_BUFFERED}: The device is either waiting for a trigger to start the execution of a buffered experiment, or is currently executing an experiment.
	\item \texttt{MODE\_TRANSITION\_TO\_MANUAL}: The device has finished executing the buffered experiment and is currently saving any acquired data and preparinfg to entered \texttt{MODE\_MANUAL}.
\end{itemize}

In general you should not need to worry about transitioning between these modes unless you are overwriting \texttt{transition\_to\_buffered} or \texttt{transition\_to\_manual}.

A state machine function can be configured to run only in one or more of these modes.
A state machine function can also be configured to stay in the queue until the state machine is in a matching mode and/or to only use the most recently queued  call of the state machine function.
The code \texttt{@define\_state} is a Python \textit{decorator}, and takes 2 required arguments and 1 optional argument.
The arguments are:

\begin{itemize}
	\item \texttt{allowed\_modes}: This in the binary OR of the modes in which the following state machine function is allowed to run in. If the statemachine is in a mode not specified here, it will not run until the state machine is in a matching mode
	\item \texttt{queue\_state\_indefinitely}: This argument should be set to True or False.
	If True, the state machine function will remain in the queue until the statemachine enters one of the allowed modes. 
	Setting this flag to True guarantees the state machine function will run eventually (unless the device tab is restarted or BLACS is closed). 
	If False, this state machine function will be removed from the queue if it is the next item in the state machine to be run, but the current state machine mode is not one of the allowed modes.
	\item \texttt{delete\_stale\_states}: An optional argument that defaults to False. If set to True, the state machine will look for newer versions of the state machine function in the queue, and will run the most recent found before encountering a different state machine function in the queue. If set to False (the default), this state will not be deleted when newer versions exist.
\end{itemize}

An example use of \texttt{@define\_state} is shown below:
\begin{python}
    @define_state(allowed_modes=MODE_MANUAL|MODE_BUFFERED,queue_state_indefinitely=True,delete_stale_states=False)
    def start(self,widget=None):
        # some code follows
        time.sleep(5)
\end{python}

Note that if we call this function from within our code, E.g.:
\begin{python}
    def foo(self):
        self.start() # This function call returns immediately
\end{python}
the call to \texttt{start} returns immediately. Some time in the future, the function \texttt{start} will be executed, and the main thread (the GUI) will sleep for 5 seconds as expected.

This means that calls to state machine functions (E.g. \texttt{start}) cannot return parameters in the conventional way. It is expected that state machine functions will be called upon a Qt event (in which case you will never need to return anything from your state) or from another thread (in which case you can use a Python Queue to block the calling thread until your state machine function puts the return values in the queue)

As mentioned, state machine functions are designed to interact with the worker process. You can call functions within your worker process with the following code:
\begin{python}
    @define_state(MODE_MANUAL,True)
    def start(self,widget=None):
        result = yield(self.queue_work(self.primary_worker,'foo'))
\end{python}

If you wish to pass arguments to your function, you can instead call something similar to
\begin{python}
        result = yield(self.queue_work(self.primary_worker,'foo',1,5,x=3))
\end{python}
This will call the function \texttt{foo} with the arguments \texttt{1,5,3} in the worker process name stored in \texttt{self.primary\_worker}.

It is important to note that you cannot pass objects as arguments to a worker class function. The arguments must be able to be placed into a Python Queue.

You may \texttt{yield} to one or more worker process function many times within a single state function.
\textbf{Note that you can only do this from within a function that is decorated with \texttt{@define\_state}.}



\subsection{Device class state machine, callback on timeout}\label{statemachine_timeout_add}
The state machine architecture of BLACS provides the functionality to register a timeout callback; that is, a function to be called (approximately) every \texttt{n} milliseconds. 
This is generally used for periodic status monitoring of a device.

To add such a timeout callback to your code, you call from within your device class:
\begin{python}
self.statemachine_timeout_add(delay,self.some_function,userdata1,...)
\end{python}
where userdata1 and following arguments are passed to \texttt{self.some\_function}.

To remove the timeout, call 
\begin{python}
self.statemachine_timeout_remove(self.some_function)
\end{python}

Due to the nature of state machines (callbacks are processed one at a time based on the order in the queue), your function is not guaranteed to run as often as you have requested. Initially, because your function is a state machine function, BLACS will add your function to the state machine queue. Once your function has run, it will add a Qt single-shot timer to run an internal function in \texttt{delay} milliseconds. This internal function will queue up your function in the state machine again, and, depending on the length of the queue at that time, may not run immediately. 

\textbf{Also note that you can only have one timeout for a given function. Creating a timeout for the same function will replace the existing timeout.}



\newpage
\section{The Worker Class}
The worker class is used solely to communicated with the hardware for our device. 
It exists to separate out the code, modules, dll's, etc. from the GUI to provide better stability to the system. 
The worker class is instantiated inside a separate process (referred to from now on as the worker process), which can be restarted by the user if the device becomes unresponsive.
Upon restart, all libraries are completely reloaded as they are only loaded within the worker process. 
This allows the system to recover from errors in 3rd party API's without the need to restart the entire control system.

The worker class consists of functions which can be executed by the state machine. 
In your device class you can call:
\begin{python}
result = yield(self.queue_work('worker_name','some_function',arg1,arg2,kwrd1=arg3))
\end{python}
and this will call the function called \texttt{some\_function} with arguments \texttt{arg1,arg2,kwrd1=arg3} in the worker process you have created and named \texttt{'my\_worker'} (not to be confused with the Worker class name). 
This is covered in more detail in section \ref{device_class_state_machine}.

\subsection{The \texttt{init} function}
The init function in the worker class is special for two reasons. 
The first is that it is not called \texttt{\_\_init\_\_} as you would expect. 
This is because we don't want to override the \texttt{\_\_init\_\_} function in class \texttt{Worker},  which is essential for successful operation.

The second is that this is the function in which you should import the modules, classes, etc. that you wish to access from within the worker class. 
They are imported here, within the class, so that they only exist within the worker process, and not within the BLACS process. 
This allows modules to be completely unloaded from the system when the worker process is restarted, and thus recovery of the programming library without the need to completely restart the program (a technique not seen in any other control system to our knowledge).
The \texttt{{init}} function will always be the first function in your worker process to be run after it has been created.

If you wish to import a module (for example \texttt{h5py}), use the following code:
\begin{python}
class MyWorker(Worker):
    def init(self):
        global h5py; import h5_lock, h5py
\end{python}
This imports both the labscript suite \texttt{h5\_lock} module (which prevents simultaneous accessing of h5 file which could cause data corruption) and the \texttt{h5py} module which is stored as a global variable.

If you wish to import something from within a module (for example one or more functions from the \texttt{spinapi} module), you can use:
\begin{python}
        exec 'from spinapi import *' in globals()
\end{python}
or
\begin{python}
        exec 'from spinapi import pb_start, pb_stop' in globals()
\end{python}

You can also set the default values for any class attributes in the \texttt{init} function. For instance:
\begin{python}
        self.smart_cache = {}
\end{python}

\subsection{The \texttt{initialise} function}
This function is automatically called by the \texttt{DeviceTab} class after worker processes are created. 
Anything done here can probably be done it \texttt{init} so this function is likely to be removed at some point in time.
It is \textbf{not} guaranteed to run immediately after \texttt{init}.
There may be other worker process functions run sooner by calls to \texttt{statemachine\_timeout\_add}.

You do however need to define an empty function here for the moment.
Please define in your worker class:
\begin{python}
    def initialise(self):
        pass
\end{python}


\subsection{The \texttt{program\_manual} function}
This function is called whenever the device needs to be programmed to output values when \textbf{not} executing a buffered shot.
The most common time this happens is when a value of a digital, analog or DDS output widget on the front panel is changed.

The function is passed an argument which contains all of the current front panel values in a dictionary.
The dictionary is keyed by the hardware channel names you defined in the \texttt{initialise\_GUI} function in your Device GUI class.

The method should return the values for each output value, coerced to the value that the device is actually outputting now.
This is to accurately reflect the device quantisation on the front panel of BLACS.
The return value should be a dictionary of the same format as the one passed in.

Your function should look something like:
\begin{python}
    def program_manual(self, front_panel_values):
        # Program the device
        # work out what values the device is actually outputting
        return modified_front_panel_values
\end{python}



\subsection{The \texttt{transition\_to\_buffered} function}
This function is called whenever the Queue Manager requests the device to move into buffered mode in preparation for executing a buffered sequence.

This function is passed the \texttt{device\_name} to look up in the HDF5 file located at the path contained by \texttt{h5file}.
The function is also passed the current initial\_values, so that your device can be programmed to maintain output continuity until the device is triggered.
This may require inserting a dummy instruction at the beginning of the instruction list provided by \texttt{labscript}.
The final argument passed to this function is a Boolean value that indicates whether the device should have it's entire instruction table overwritten (only applies to device classes that have called \texttt{self.supports\_smart\_programming(True)} in the \texttt{initialise\_GUI} function).

The function should return a dictionary containing the final value of each output once the buffered shot has finished execution.
The dictionary should be keyed by the hardware channel names you defined in the \texttt{initialise\_GUI} function in your Device GUI class.

\textbf{Note:} you should avoid holding the HDF5 file open when programming the device. Open the file, copy the data into local memory, close the file and the program the device.
This will allow other devices to access the file to begin their programming process, and will minimise your experiment cycle time.

Example:
\begin{python}
    def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
        # Open HDF5 file
        # copy device data to local memory
        # close HDF5 file
        #
        # check whether we need to do a completely fresh program or not
        # Check whether the data for this shot is similar enough to the last shot
        #       and whether only some instructions need reprogramming
        # 
        # build final value dictionary
        return final_experiment_values
\end{python}

\subsection{The \texttt{transition\_to\_manual} function}
This function is called after the master pseudoclock reports that the experiment has finished. 
This function takes no arguments, should place the device back in the correct mode for operation by the front panel of BLACS, and return a Boolean flag indicating the success of this method.
Any acquisitions made during the buffered shot should be saved to the HDF5 file now (you must store a reference to the HDF5 file in \texttt{transition\_to\_buffered} if you need to access it in \texttt{transition\_to\_manual}).

Example:
\begin{python}
    def transition_to_manual(self):
        # save any acquired data to HDF5 file
        # place device in mode ready for BLACS front panel control
        # return True if this was all successful, or False otherwise
        return True/False
\end{python}

\subsection{Abort functions}
There are two functions that may be called if something went wrong and the experiment shot is to be aborted.
The first, \texttt{abort\_transition\_to\_buffered}, is called if the experiment shot must be aborted \textbf{before} the master pseudoclock has been triggered to begin.
The second, \texttt{abort\_buffered}, is called if the shot must be aborted during the execution of a buffered shot.
Both functions take no arguments (other than \texttt{self}) and should return \texttt{True} or \texttt{False} depending on whether they were successful and the device is ready for front panel input from BLACS again.
If False is returned, this will cause an error to be displayed requesting the user to \textbf{restart} the device tab themselves. 

Example
\begin{python}
    def abort_buffered(self):
        # place the device back in manual mode, while in the middle
        #       of an experiment shot
        # return True if this was all successful, or False otherwise
        return True/False
		
    def abort_transition_to_buffered(self):
        # place the device back in manual mode, after the device has run
        #       transition_to_buffered, but has not been triggered to 
        #       begin the experiment shot.
        # return True if this was all successful, or False otherwise
        return True/False		
\end{python}


\subsection{The shutdown function}
The shutdown function is called when BLACS is asked to close.
This should put the device in safe state, for example closing any open communication connections with the device.
The function should not return any value (the return value is ignored)

Example:
\begin{python}
    def shutdown(self):
        # close any open connections
        # place the device in a nice state
        # return nothing
\end{python}

\end{document}
